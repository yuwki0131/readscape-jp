# 5.1 アプリケーション成果物

## 概要
本番環境で実行可能なアプリケーション成果物とその配布形態を定義します。

## JAR/WAR ファイル

### 実行可能JARの生成
```gradle
// build.gradle のJAR作成設定
jar {
    enabled = false  // 通常のJARは無効化
    archiveClassifier = ''
}

bootJar {
    enabled = true
    archiveFileName = 'readscape-api.jar'
    
    // メインクラス指定
    mainClass = 'jp.readscape.api.ReadscapeBackendApplication'
    
    // 実行時情報の埋め込み
    manifest {
        attributes(
            'Implementation-Title': project.name,
            'Implementation-Version': project.version,
            'Implementation-Vendor': 'Readscape-JP Team',
            'Built-Date': new Date().format('yyyy-MM-dd HH:mm:ss'),
            'Built-JDK': System.getProperty('java.version'),
            'Built-Gradle': gradle.gradleVersion,
            'Main-Class': 'org.springframework.boot.loader.JarLauncher'
        )
    }
    
    // 不要なファイルの除外
    exclude '**/application-dev.yml'
    exclude '**/application-test.yml'
    exclude '**/*Test.class'
}
```

### ファットJAR設定
```gradle
// 依存ライブラリを含むファットJAR作成
bootJar {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    
    // 外部設定ファイルの分離
    exclude 'application.yml'
    exclude 'application-*.yml'
    
    // バージョン情報ファイル生成
    doFirst {
        def versionFile = file("${temporaryDir}/version.properties")
        versionFile.text = """
version=${project.version}
buildTime=${new Date().format('yyyy-MM-dd HH:mm:ss')}
gitCommit=${getGitCommitHash()}
"""
        
        from(versionFile) {
            into 'META-INF'
        }
    }
}

def getGitCommitHash() {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', 'HEAD'
        standardOutput = stdout
    }
    return stdout.toString().trim().substring(0, 8)
}
```

### WAR ファイル生成（必要時）
```gradle
// WARプラグイン適用
apply plugin: 'war'

war {
    archiveFileName = 'readscape-api.war'
    enabled = true
    
    // 外部Tomcat用の設定
    providedCompile 'org.springframework.boot:spring-boot-starter-tomcat'
}

// SpringBootServletInitializer の実装
@SpringBootApplication
public class ReadscapeBackendApplication extends SpringBootServletInitializer {

    public static void main(String[] args) {
        SpringApplication.run(ReadscapeBackendApplication.class, args);
    }

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(ReadscapeBackendApplication.class);
    }
}
```

## Dockerイメージ

### アプリケーション用Dockerfile
```dockerfile
# マルチステージビルド
FROM gradle:8.5-jdk21 AS builder

WORKDIR /app

# Gradle設定のコピー
COPY build.gradle settings.gradle gradlew ./
COPY gradle/ gradle/

# 依存関係の事前ダウンロード（キャッシュ効率化）
RUN gradle dependencies --no-daemon

# ソースコードのコピーとビルド
COPY src/ src/
RUN gradle bootJar --no-daemon

# 本番用イメージ
FROM openjdk:21-jdk-slim

# セキュリティ強化
RUN groupadd -r readscape && useradd -r -g readscape readscape

# 必要なツールのインストール
RUN apt-get update && apt-get install -y \
    curl \
    dumb-init \
    && rm -rf /var/lib/apt/lists/*

# アプリケーション設定
WORKDIR /app

# 設定ファイル用ディレクトリ
RUN mkdir -p /app/config /app/logs && \
    chown -R readscape:readscape /app

# JAR ファイルのコピー
COPY --from=builder /app/build/libs/readscape-api.jar /app/readscape-api.jar
COPY --chown=readscape:readscape docker/application.yml /app/config/

# 実行ユーザー切り替え
USER readscape

# ヘルスチェック
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
  CMD curl -f http://localhost:8080/api/actuator/health || exit 1

# JVM最適化オプション
ENV JAVA_OPTS="-Xms512m -Xmx2048m -XX:+UseG1GC -XX:+UseStringDeduplication"

EXPOSE 8080

# dumb-init でPID1問題を回避
ENTRYPOINT ["dumb-init", "--"]
CMD ["sh", "-c", "java $JAVA_OPTS -jar readscape-api.jar --spring.config.location=file:/app/config/application.yml"]
```

### 最適化されたDockerfile
```dockerfile
# 軽量ベースイメージ使用
FROM eclipse-temurin:21-jre-alpine

# Alpine用パッケージ管理
RUN apk --no-cache add curl dumb-init

# 非rootユーザー作成
RUN addgroup -S readscape && adduser -S -G readscape readscape

WORKDIR /app

# レイヤーキャッシュ最適化のためJARを展開
COPY build/libs/readscape-api.jar app.jar
RUN java -Djarmode=layertools -jar app.jar extract && \
    chown -R readscape:readscape /app

USER readscape

# レイヤー別コピーでキャッシュ効率化
COPY --chown=readscape:readscape dependencies/ ./
COPY --chown=readscape:readscape spring-boot-loader/ ./
COPY --chown=readscape:readscape snapshot-dependencies/ ./
COPY --chown=readscape:readscape application/ ./

HEALTHCHECK --interval=30s --timeout=10s --retries=3 \
  CMD curl -f http://localhost:8080/api/actuator/health

EXPOSE 8080

ENTRYPOINT ["dumb-init", "java", "org.springframework.boot.loader.JarLauncher"]
```

### Docker Compose 本番設定
```yaml
version: '3.8'

services:
  readscape-api:
    image: readscape/readscape-api:latest
    container_name: readscape-api-prod
    restart: unless-stopped
    
    ports:
      - "8080:8080"
    
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - DB_HOST=postgres
      - DB_NAME=readscape_prod
      - DB_USER=${DB_USER}
      - DB_PASSWORD=${DB_PASSWORD}
      - JWT_SECRET=${JWT_SECRET}
    
    volumes:
      - ./config/application-prod.yml:/app/config/application.yml:ro
      - readscape_logs:/app/logs
    
    depends_on:
      postgres:
        condition: service_healthy
    
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/api/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 40s
    
    networks:
      - readscape-network
    
    # リソース制限
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M
    
    logging:
      driver: "json-file"
      options:
        max-size: "200m"
        max-file: "10"

  postgres:
    image: postgres:15
    container_name: readscape-postgres
    restart: unless-stopped
    
    environment:
      POSTGRES_DB: readscape_prod
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      PGDATA: /var/lib/postgresql/data/pgdata
    
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./config/postgres.conf:/etc/postgresql/postgresql.conf:ro
    
    command: postgres -c config_file=/etc/postgresql/postgresql.conf
    
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
    driver: local
  readscape_logs:
    driver: local

networks:
  readscape-network:
    driver: bridge
```

## 設定ファイル群

### 環境別設定ファイル
```yaml
# config/application-prod.yml
spring:
  datasource:
    url: jdbc:postgresql://${DB_HOST}:${DB_PORT:5432}/${DB_NAME}
    username: ${DB_USER}
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      validation-timeout: 5000
      idle-timeout: 600000
      max-lifetime: 1800000
      leak-detection-threshold: 60000

  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        jdbc:
          time_zone: Asia/Tokyo

  security:
    jwt:
      secret: ${JWT_SECRET}
      expiration: 3600000

server:
  port: 8080
  tomcat:
    max-threads: 200
    min-spare-threads: 10
    max-connections: 8192
    accept-count: 100
    connection-timeout: 20000

logging:
  level:
    root: INFO
    jp.readscape: INFO
  file:
    name: /app/logs/readscape-api.log
    max-size: 100MB
    max-history: 30

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: when_authorized
  metrics:
    export:
      prometheus:
        enabled: true
```

### システム設定テンプレート
```bash
# systemd サービスファイル
# /etc/systemd/system/readscape-api.service

[Unit]
Description=Readscape API Service
After=network.target postgresql.service
Wants=postgresql.service

[Service]
Type=simple
User=readscape
Group=readscape
WorkingDirectory=/opt/readscape
ExecStart=/usr/bin/java -jar readscape-api.jar
ExecStop=/bin/kill -TERM $MAINPID
Restart=on-failure
RestartSec=10
StandardOutput=journal
StandardError=journal
SyslogIdentifier=readscape-api

# 環境変数
Environment=SPRING_PROFILES_ACTIVE=prod
Environment=JAVA_OPTS=-Xms512m -Xmx2048m -XX:+UseG1GC

# セキュリティ設定
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=strict
ReadWritePaths=/opt/readscape/logs
ProtectHome=yes

[Install]
WantedBy=multi-user.target
```

### nginx リバースプロキシ設定
```nginx
# /etc/nginx/sites-available/readscape-api

upstream readscape_backend {
    server 127.0.0.1:8080;
    keepalive 32;
}

server {
    listen 80;
    server_name api.readscape.jp;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name api.readscape.jp;

    # SSL設定
    ssl_certificate /etc/letsencrypt/live/api.readscape.jp/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/api.readscape.jp/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;

    # セキュリティヘッダー
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # API プロキシ設定
    location / {
        proxy_pass http://readscape_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # タイムアウト設定
        proxy_connect_timeout 30s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;
    }

    # ヘルスチェックエンドポイント
    location /api/actuator/health {
        proxy_pass http://readscape_backend;
        access_log off;
    }

    # 静的ファイル（必要時）
    location /static/ {
        alias /var/www/readscape/static/;
        expires 30d;
        add_header Cache-Control "public, no-transform";
    }
}
```

## 配布パッケージング

### リリースアーティファクト作成
```gradle
// リリース用タスク
task createReleasePackage(type: Zip) {
    archiveFileName = "readscape-api-${version}-release.zip"
    destinationDirectory = file("$buildDir/distributions")
    
    from bootJar
    from('config/') {
        into 'config'
        include 'application-prod.yml.template'
        include 'logback-spring.xml'
    }
    from('scripts/') {
        into 'scripts'
        include 'install.sh'
        include 'start.sh' 
        include 'stop.sh'
        fileMode = 0755
    }
    from('docker/') {
        into 'docker'
        include 'Dockerfile'
        include 'docker-compose.prod.yml'
    }
    from 'README.md'
    from 'CHANGELOG.md'
    
    // バージョン情報ファイル
    doFirst {
        def versionInfo = file("${temporaryDir}/VERSION")
        versionInfo.text = """
Version: ${version}
Build Date: ${new Date()}
Git Commit: ${getGitCommitHash()}
"""
        from versionInfo
    }
}
```

### インストールスクリプト
```bash
#!/bin/bash
# scripts/install.sh

set -e

APP_NAME="readscape-api"
APP_USER="readscape"
APP_DIR="/opt/readscape"
SERVICE_FILE="/etc/systemd/system/readscape-api.service"

echo "Installing $APP_NAME..."

# ユーザー作成
if ! id "$APP_USER" &>/dev/null; then
    sudo useradd -r -s /bin/false $APP_USER
    echo "Created user: $APP_USER"
fi

# ディレクトリ作成
sudo mkdir -p $APP_DIR/logs
sudo chown -R $APP_USER:$APP_USER $APP_DIR

# JARファイルコピー
sudo cp readscape-api.jar $APP_DIR/
sudo chown $APP_USER:$APP_USER $APP_DIR/readscape-api.jar

# 設定ファイルコピー
sudo mkdir -p $APP_DIR/config
if [ -f "config/application-prod.yml" ]; then
    sudo cp config/application-prod.yml $APP_DIR/config/
else
    echo "Warning: application-prod.yml not found. Using template."
    sudo cp config/application-prod.yml.template $APP_DIR/config/application-prod.yml
fi

# systemd サービス登録
sudo cp systemd/readscape-api.service $SERVICE_FILE
sudo systemctl daemon-reload
sudo systemctl enable readscape-api

echo "Installation completed!"
echo "Configure $APP_DIR/config/application-prod.yml and start with:"
echo "  sudo systemctl start readscape-api"
```

## 技術仕様
- ビルドツール: Gradle 8.5 with Spring Boot Plugin
- パッケージング: Executable JAR with Fat JAR
- コンテナ: Docker with multi-stage build
- 配布形式: ZIP archive with scripts
- 設定管理: External configuration files